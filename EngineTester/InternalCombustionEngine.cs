using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EngineTester
{
    /// <summary>
    /// Class for the Internal Combustion Engine. Inherits from the Engine class
    /// </summary>
    internal class InternalCombustionEngine : Engine
    {
        double[] _torques { get; set; } // M - torques generated by the engine at certain cranckshaft velocities (N*m)
        double[] _velocities { get; set; } // V - cranckhaft velocities at which the engine produces torque (rad/sec)
        double _ratioTorque { get; set; } // Hm - ratio of heating up from torque (C/(N*m*sec))
        double _ratioVelocity { get; set; } // Hv - ratio of heating up from crancksaft velocity ((C*sec)/rad^2)


        /// <summary>
        /// Constructor for the InternalCombustionEngine class
        /// </summary>
        /// <param name="inertia">Moment of intertia (I)</param>
        /// <param name="torques">Torques generated by the engine at certain cranckshaft velocities (M)</param>
        /// <param name="velocities">Cranckhaft velocities at which the engine produces torque (V)</param>
        /// <param name="tempOverheat">Overheating temperature (Toverheat)</param>
        /// <param name="ratioTorque">Ratio of heating up from torque (Hm)</param>
        /// <param name="ratioVelocity">Ratio of heating up from crancksaft velocity (Hv)</param>
        /// <param name="ratioCooling">Ratio of cooling effectiveness based on engine temp and environment temp (C)</param>
        /// <param name="tempEnvinroment">Envinronment temperature (Tenvironment)</param>
        /// <exception cref="ArgumentException"></exception>
        public InternalCombustionEngine(
            double inertia, 
            double[] torques, 
            double[] velocities, 
            double tempOverheat, 
            double ratioTorque,
            double ratioVelocity,
            double ratioCooling, 
            double tempEnvinroment
            ) : base(inertia, tempOverheat, ratioCooling, tempEnvinroment)
        {
            // If the two arrays are of different length, something went very wrong
            if (torques.Length != velocities.Length)
            {
                throw new ArgumentException("torques and cranckshaftVs must be the same length");
            }

            _torques = torques;
            _velocities = velocities;
            _ratioTorque = ratioTorque;
            _ratioVelocity = ratioVelocity;
        }

        /// <summary>
        /// Get current torque based on the current cranckshaft velocity
        /// </summary>
        /// <returns>Current torque</returns>
        private double GetCurrentTorque()
        {
            // If the cranckshaft V is in array, return take the corresponding torque
            int index = Array.IndexOf(_velocities, _velocity);
            if (index != -1)
            {
                return _torques[index];
            }

            // If not, get the two surrounding pairs of values, and find the line with the equation y = kx+b that goes through them (where y = torque, x = cranckV)
            for (int i=1; i<_velocities.Length; i++)
            {
                if ((_velocities[i-1] < _velocity) && (_velocity < _velocities[i]))
                {
                    double k = (_torques[i] - _torques[i - 1]) / (_velocities[i] - _velocities[i - 1]);
                    double b = _torques[i] - (_velocities[i] * k);
                    return (k * _velocity) + b;
                }
            }

            // Should be unreachable
            throw new IndexOutOfRangeException("Couldn't get current torque (probably an error in code)");

        }

        /// <summary>
        /// Get cool down per second, based on the formula
        /// Vc = C * (Tenvironment - Tengine) [C/sec]
        /// </summary>
        public override double GetTemperatureCooldown()
        {
            return _ratioCooling * (_tempEnvinroment - _tempEngine);
        }

        /// <summary>
        /// Get heat up per second, based on the formula
        /// Vh = M * Hm + V^2 * Hv [C/sec]
        /// </summary>
        public override double GetTemperatureHeatUp()
        {
            return (_torque * _ratioTorque) + ((_velocity * _velocity) * _ratioVelocity);
        }

        /// <summary>
        /// Apply both the heating up and the cooling down simultaneously 
        /// </summary>
        /// <exception cref="NotImplementedException"></exception>
        public override void EngineChangeTemperature()
        {
            _tempEngine = _tempEngine + GetTemperatureCooldown() + GetTemperatureHeatUp();
        }

        /// <summary>
        /// Get current engine acceleration; since the engine is running without load, the formula is
        /// a = m/I
        /// </summary>
        /// <returns>acceleration</returns>
        public override double Acceleration()
        {
            return _torque / _inertia;
        }

        /// <summary>
        /// Simulate a second of the engine working
        /// </summary>
        public override void SimulateSecond()
        {
            _torque = GetCurrentTorque();
            _velocity += Acceleration();
            EngineChangeTemperature();
        }
    }
}
