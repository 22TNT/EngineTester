using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EngineTester
{
    /// <summary>
    /// Class for the Internal Combustion Engine. Inherits from the Engine class
    /// </summary>
    internal class InternalCombustionEngine : Engine
    {
        double[] _torques { get; set; } // M - torques generated by the engine at certain cranckshaft velocities (N*m)
        double[] _cranckshaftVs { get; set; } // V - cranckhaft velocities at which the engine produces torque (rad/sec)
        double _ratioTorque { get; set; } // Hm - ratio of heating up from torque (C/(N*m*sec))
        double _ratioCranckshaftV { get; set; } // Hv - ratio of heating up from crancksaft velocity ((C*sec)/rad^2)

        double _torque { get; set; } // m - current torque
        double _cranckshaftV { get; set; } // v - current velocity


        /// <summary>
        /// Constructor for the InternalCombustionEngine class
        /// </summary>
        /// <param name="inertia">Moment of intertia (I)</param>
        /// <param name="torques">Torques generated by the engine at certain cranckshaft velocities (M)</param>
        /// <param name="cranckshaftVs">Cranckhaft velocities at which the engine produces torque (V)</param>
        /// <param name="tempOverheat">Overheating temperature (Toverheat)</param>
        /// <param name="ratioTorque">Ratio of heating up from torque (Hm)</param>
        /// <param name="ratioCranckshaftV">Ratio of heating up from crancksaft velocity (Hv)</param>
        /// <param name="ratioCooling">Ratio of cooling effectiveness based on engine temp and environment temp (C)</param>
        /// <param name="tempEnvinroment">Envinronment temperature (Tenvironment)</param>
        /// <exception cref="ArgumentException"></exception>
        public InternalCombustionEngine(
            double inertia, 
            double[] torques, 
            double[] cranckshaftVs, 
            double tempOverheat, 
            double ratioTorque,
            double ratioCranckshaftV,
            double ratioCooling, 
            double tempEnvinroment
            ) : base(inertia, tempOverheat, ratioCooling, tempEnvinroment)
        {
            // If the two arrays are of different length, something went very wrong
            if (torques.Length != cranckshaftVs.Length)
            {
                throw new ArgumentException("torques and cranckshaftVs must be the same length");
            }

            _torques = torques;
            _cranckshaftVs = cranckshaftVs;
            _ratioTorque = ratioTorque;
            _ratioCranckshaftV = ratioCranckshaftV;
        }

        /// <summary>
        /// Get current torque based on the current cranckshaft velocity
        /// </summary>
        /// <returns>Current torque</returns>
        private double GetCurrentTorque()
        {
            // If the cranckshaft V is in array, return take the corresponding torque
            int index = Array.IndexOf(_cranckshaftVs, _cranckshaftV);
            if (index != -1)
            {
                return _torques[index];
            }

            // If not, get the two surrounding pairs of values, and find the line with the equation y = kx+b that goes through them (where y = torque, x = cranckV)
            for (int i=1; i<_cranckshaftVs.Length; i++)
            {
                if ((_cranckshaftVs[i-1] < _cranckshaftV) && (_cranckshaftV < _cranckshaftVs[i]))
                {
                    double k = Math.Abs((_torques[i] - _torques[i - 1])) / Math.Abs(_cranckshaftVs[i] - _cranckshaftVs[i - 1]);
                    double b = _torques[i] - (_cranckshaftVs[i] * k);
                    return (k * _cranckshaftV) + b;
                }
            }

            // Should be unreachable
            throw new IndexOutOfRangeException("Couldn't get current torque (probably an error in code)");

        }

        /// <summary>
        /// Engine cooling method, based on the formula
        /// Tengine = Tengine + Vc [C];
        /// Vc = C * (Tenvironment - Tengine) [C/sec]
        /// </summary>
        /// <exception cref="NotImplementedException"></exception>
        public override void EngineCooling()
        {
            _tempEngine += _ratioCooling * (_tempEnvinroment - _tempEngine);
        }

        /// <summary>
        /// Engine heat up method, based on the formula
        /// Tengine = Tengine + Vh [C];
        /// Vh = M * Hm + V^2 * Hv [C/sec]
        /// </summary>
        /// <exception cref="NotImplementedException"></exception>
        public override void EngineHeatUp()
        {
            _tempEngine += (_torque * _ratioTorque) + ((_cranckshaftV) * _ratioCranckshaftV);
        }

        /// <summary>
        /// Get current engine acceleration; since the engine is running without load, the formula is
        /// a = m/I
        /// </summary>
        /// <returns>acceleration</returns>
        public override double Acceleration()
        {
            return _torque / _inertia;
        }
    }
}
